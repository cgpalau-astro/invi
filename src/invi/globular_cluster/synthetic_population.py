"""Generate synthetic population from CMD37 (Colour Magnitude Diagram 37).

Example
-------
import tomllib
import invi.globular_cluster.synthetic_population as sp

#Load parameters
with open("../data/parameters.toml", "rb") as f:
    prm = tomllib.load(f)

#Load synthetic population from CMD37
mass = prm['M68']['M_initial']
cmd_file = "../data/synthetic_population/population.dat.zip"
synthetic_population = sp.generate(mass, cmd_file)"""

import termcolor as _tc
import numpy as _np

import fnc as _fnc
_pd = _fnc.utils.lazy.Import("pandas")

__all__ = ["generate", "load", "Kroupa"]

#-----------------------------------------------------------------------------

def _load_CMD_file(name_file, type_file="population", shuffle=False, random_state=None, verbose=True):
    """Load data from files generated by CMD37.

    Web
    ---
    1)  http://stev.oapd.inaf.it/cgi-bin/cmd

    Note
    ----
    1)  The name of the columns are different for the 'isochrone' and
        'synthetic' population files.
    2)  In the synthetic file there is a repeated column 'Z'. The second
        is renamed 'Z2'.

    Example:
    --------
    name_file = "../data/synthetic_population/population.dat.zip"
    cmd = load_CMD_file(name_file)"""
    #-------------------------------------------------
    #Select name columns
    if type_file == "isochrone":
        columns = ['Zini', 'MH', 'logAge', 'Mini', 'int_IMF', 'Mass',
                   'logL', 'logTe', 'logg', 'label', 'McoreTP', 'C_O',
                   'period0', 'period1', 'period2','period3', 'period4',
                   'pmode', 'Mloss', 'tau1m', 'X', 'Y', 'Xc', 'Xn', 'Xo',
                   'Cexcess', 'Z', 'mbolmag', 'Gmag', 'G_BPmag', 'G_RPmag']
    elif type_file == "population":
        columns = ['Z', 'age', 'Mini', 'Mass', 'logL', 'logTe', 'logg',
                   'label', 'McoreTP', 'C_O', 'period0', 'period1',
                   'period2', 'period3', 'period4', 'pmode', 'Mloss',
                   'tau1m', 'X', 'Y', 'Xc', 'Xn', 'Xo', 'Cexcess', 'Z2',
                   'mbolmag', 'Gmag', 'G_BPmag', 'G_RPmag']
    else:
        raise ValueError("type_file = {isochrone, population}")
    #---------------------------------------------------
    #Load data frame
    df = _pd.read_csv(name_file, sep=r'\s+', skiprows=14, skipfooter=1, engine='python', names=columns)
    #Shuffle rows
    if shuffle:
        df = df.sample(frac=1, replace=False, random_state=random_state).reset_index(drop=True)
    #columns = list(df.columns)
    #---------------------------------------------------
    #Definition dictionary
    cmd = {}

    #Absolute magnitudes [mag]
    cmd['G'] = df.Gmag.values
    cmd['BP'] = df.G_BPmag.values
    cmd['RP'] = df.G_RPmag.values
    cmd['BPRP'] = cmd['BP'] - cmd['RP']

    cmd['mass'] = df.Mass.values #[M_sun]
    cmd['logg'] = df.logg.values
    cmd['Teff'] = 10.0**df.logTe.values #[K]

    cmd['type'] = df.label.values
    #---------------------------------------------------
    if verbose:
        #Number stars
        n_stars = df.shape[0]
        #Memory used by the data frame
        used_memory_B = df.memory_usage(deep=True).sum()
        used_memory = _fnc.utils.human_readable.memory(used_memory_B)
        _tc.cprint("CMD data:", 'light_blue')
        print(f"   Type file = {type_file}")
        print(f"Number stars = {n_stars:_}")
        print(f" Used memory = {used_memory}")
        print(f"     Shuffle = {shuffle}")
        if shuffle:
            print(f"Random state = {random_state}")
    #---------------------------------------------------
    return cmd

#-----------------------------------------------------------------------------

def _determine_number_stars(mass, mass_sample, rounding='superior'):
    """Number of stars with masses following 'mass_sample' such that their
    total mass approximately is equal to 'mass'.

    Parameters
    ----------
    mass : float
        Total mass
    mass_sample : array like
        Sample of star masses
    rounding : {'inferior', 'superior'}
        Inferior or superior rounding

    Returns
    -------
    numpy.int64
        Number of stars"""
    #------------------------------------------------------
    if rounding not in ('inferior', 'superior'):
        raise ValueError("rounding = {inferior, superior}")

    if _np.sum(mass_sample) < mass:
        raise ValueError("sum(sample) < mass")
    #------------------------------------------------------
    #Determine number of stars
    n_stars = _np.argmin( _np.abs( _np.cumsum(mass_sample) - mass ) ) + 1

    #Apply rounding to n_stars
    if rounding == 'superior':
        if _np.sum(mass_sample[0:n_stars]) < mass:
            n_stars += 1

    if rounding == 'inferior':
        if _np.sum(mass_sample[0:n_stars]) > mass:
            n_stars -= 1

    return n_stars

#-----------------------------------------------------------------------------

def generate(mass, cmd_file, verbose=True):
    """Generate synthetic population of 'mass' from a CMD data file."""

    #Load CMD synthetic population
    cmd = _load_CMD_file(cmd_file, verbose=verbose)

    #Determine number stars in the cluster
    rounding = 'superior'
    n_stars = _determine_number_stars(mass=mass, mass_sample=cmd['mass'], rounding=rounding)

    #Cut CMD data
    synthetic_population = {}
    for key in cmd:
        synthetic_population[key] = cmd[key][0:n_stars]
    #-----------------------------------------------------
    if verbose:
        _tc.cprint("Synthetic population:", 'light_blue')
        print(f"Number stars = {n_stars:_}")
        total_mass = _np.sum(cmd['mass'][0:n_stars])
        print(f"  Total mass = {total_mass:0.5f} [M_sun]")
        print(f"    Rounding = {rounding}")
    #-----------------------------------------------------
    return synthetic_population

#-----------------------------------------------------------------------------

def load(n_stars, cmd_file, shuffle=False, random_state=None, verbose=True):
    """Generate synthetic population of 'n_stars' from a CMD data file."""

    #Shuffle requires a random_state
    if shuffle and random_state is None:
        raise ValueError("If 'shuffle' is True, 'random_state' must be int.")
    if not shuffle and random_state is not None:
        raise ValueError("If 'shuffle' is False,'random_state' must be None.")

    #Load CMD synthetic population
    cmd = _load_CMD_file(cmd_file, shuffle=shuffle, random_state=random_state, verbose=verbose)

    #Check number of stars
    n_tot = len(cmd['mass'])
    if n_stars > n_tot:
        raise ValueError(f"n_stars must be smaller thant the total number of stars in the cmd file: n_stars = {n_stars:_} > {n_tot:_} = n_tot")

    #Cut CMD data
    synthetic_population = {}
    for key in cmd:
        synthetic_population[key] = cmd[key][0:n_stars]
    #-----------------------------------------------------
    if verbose:
        _tc.cprint("Synthetic population:", 'light_blue')
        print(f"Number stars = {n_stars:_}")
        total_mass = _np.sum(cmd['mass'][0:n_stars])
        print(f"  Total mass = {total_mass:0.5f} [M_sun]")
    #-----------------------------------------------------
    return synthetic_population

#-----------------------------------------------------------------------------

def _const(a, b, c, alpha, beta):
    t0 = alpha + 1.0
    t1 = beta + 1.0
    t2 = b**(alpha - beta)

    inv_C1 = (b**t0 - a**t0)/t0 + t2*(c**t1 - b**t1)/t1

    C1 = 1.0/inv_C1
    C2 = C1*t2

    return C1, C2


@_np.vectorize
def _pdf(x, a, b, c, alpha, beta, C1, C2):
    if a <= x <= b:
        return C1*x**alpha
    elif b < x <= c:
        return C2*x**beta
    else:
        return _np.nan


class Kroupa:
    """Kroupa Initial Mass Function as used by CMD37."""

    def __init__(self):
        self.a = 0.1
        self.b = 0.5
        self.c = 0.792
        self.alpha = -1.3
        self.beta = -2.3

    def pdf(self, x):
        a, b, c, alpha, beta = self.__dict__.values()
        C1, C2 = _const(a, b, c, alpha, beta)
        return _pdf(x, a, b, c, alpha, beta, C1, C2)

    def mean(self):
        a, b, c, alpha, beta = self.__dict__.values()
        C1, C2 = _const(a, b, c, alpha, beta)
        t3 = alpha + 2.0
        t4 = beta + 2.0
        return C1*(b**t3 - a**t3)/t3 + C2*(c**t4 - b**t4)/t4

#-----------------------------------------------------------------------------
